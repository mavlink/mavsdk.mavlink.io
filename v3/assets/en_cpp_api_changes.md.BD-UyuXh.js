import{_ as s,c as e,al as n,o as t}from"./chunks/framework.JotrKMnz.js";const u=JSON.parse('{"title":"API Changes","description":"","frontmatter":{"github_branch":"v3"},"headers":[],"relativePath":"en/cpp/api_changes.md","filePath":"en/cpp/api_changes.md"}'),i={name:"en/cpp/api_changes.md"};function o(p,a,l,r,c,d){return t(),e("div",null,a[0]||(a[0]=[n(`<h1 id="api-changes" tabindex="-1">API Changes <a class="header-anchor" href="#api-changes" aria-label="Permalink to &quot;API Changes&quot;">​</a></h1><p>This page tracks changes between versions.</p><p>It covers both breaking (incompatible) and non-breaking changes.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>All examples below are assuming <code>using namespace mavsdk</code>.</p></div><h2 id="semantic-versioning" tabindex="-1">Semantic Versioning <a class="header-anchor" href="#semantic-versioning" aria-label="Permalink to &quot;Semantic Versioning&quot;">​</a></h2><p>MAVSDK follows <a href="https://semver.org/" target="_blank" rel="noreferrer">semver/Semantic Versioning</a> conventions where as possible.</p><p>The version number has the format: <strong>major.minor.patch</strong>. Individual parts of the number are iterated when the:</p><ul><li><strong>major</strong>: API is changed, or functionality is removed.</li><li><strong>minor</strong>: API is extended, functionality is added.</li><li><strong>patch</strong>: API is not changed, functionality is not changed, but a bug is fixed.</li></ul><p>This means that breaking changes to the API result in a bump of the major version number (e.g. 1.4.3 to 2.0.0).</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Bumping of the major version is unrelated to the stability of the library. E.g. v2.0.0 is not by definition more stable than v1.4.18. It just means that the API has changed with v2. As development is carried on, stability is likely increasing whenever the minor or patch versions increase as incremental fixes are added.</p></div><h2 id="v3" tabindex="-1">v3 <a class="header-anchor" href="#v3" aria-label="Permalink to &quot;v3&quot;">​</a></h2><h3 id="connections" tabindex="-1">Connections <a class="header-anchor" href="#connections" aria-label="Permalink to &quot;Connections&quot;">​</a></h3><p>In the past the connection syntax has caused quite a bit of confusion. Therefore, we decided to adapt the syntax for UDP and TCP connections slightly, mostly adopting the syntax that&#39;s already used in other software such as for instance pymavlink and mavlink-router.</p><p>The change makes it explicit whether we are listening on a port (think server), or connecting to a port (think client).</p><p>The new syntax for the 3 connection methods are described below:</p><h4 id="udp-connections" tabindex="-1">UDP connections <a class="header-anchor" href="#udp-connections" aria-label="Permalink to &quot;UDP connections&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- UDP in  (server): udpin://our_ip:port</span></span>
<span class="line"><span>- UDP out (client): udpout://remote_ip:port</span></span></code></pre></div><p>For <code>udpin</code>, where we bind locally to that port, the IP can be set to:</p><ul><li><code>0.0.0.0</code> to listen on all network interfaces.</li><li><code>127.0.0.1</code> to listen on the local loopback interface only.</li><li>to our IP which means we listen on this network interfaces only.</li></ul><h4 id="tcp-connections" tabindex="-1">TCP connections <a class="header-anchor" href="#tcp-connections" aria-label="Permalink to &quot;TCP connections&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- TCP in  (server):  tcpin://our_ip:port</span></span>
<span class="line"><span>- TCP out (client): tcpout://remote_ip:port</span></span></code></pre></div><p>For <code>tcpin</code>, where we listen locally on that port, the IP can be set to:</p><ul><li><code>0.0.0.0</code> to listen on all network interfaces.</li><li><code>127.0.0.1</code> to listen on the local loopback interface only.</li><li>to our IP which means we listen on this network interfaces only.</li></ul><h4 id="serial-connections" tabindex="-1">Serial connections <a class="header-anchor" href="#serial-connections" aria-label="Permalink to &quot;Serial connections&quot;">​</a></h4><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>- Serial: serial://dev_node:baudrate</span></span>
<span class="line"><span>- Serial with flow control: serial_flowcontrol://dev_node:baudrate</span></span></code></pre></div><p>This is unchanged apart from the one caveat that the baudrate is no longer optional. This is to avoid cases where the baudrate is omitted by mistake.</p><h3 id="mavsdk-configuration" tabindex="-1">Mavsdk configuration <a class="header-anchor" href="#mavsdk-configuration" aria-label="Permalink to &quot;Mavsdk configuration&quot;">​</a></h3><p><code>ComponentType</code> is moved out of <code>Mavsdk</code> to its own scope, so the instantiation changes as follows:</p><p>Old instantiation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk{Mavsdk::Configuration{Mavsdk::ComponentType::GroundStation}};</span></span></code></pre></div><p>New instantiation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk{Mavsdk::Configuration{ComponentType::GroundStation}};</span></span></code></pre></div><h3 id="camera-plugin-major-redesign" tabindex="-1">Camera plugin: major redesign <a class="header-anchor" href="#camera-plugin-major-redesign" aria-label="Permalink to &quot;Camera plugin: major redesign&quot;">​</a></h3><p>The camera plugin API and internals have changed considerably. The aim was to be able to address multiple cameras from one plugin which enables more than one camera to be used in language wrappers such as Python. This wasn&#39;t previously possible.</p><p>Moreover, we now support MAVLink FTP and https to download the camera definition files, and not just http:</p><p>The API has changed to include a camera ID. Below is an example how usage changes:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span></span></span>
<span class="line"><span>auto camera = Camera{system};</span></span>
<span class="line"><span>camera.select_camera(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>auto result = camera.zoom_range(component_id, 2.0f);</span></span></code></pre></div><p>To:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>auto camera = Camera{system};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Assuming one camera is connected:</span></span>
<span class="line"><span>assert(camera.camera_list().cameras.size() == 1);</span></span>
<span class="line"><span>auto component_id = camera.camera_list().cameras[0].component_id;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>auto result = camera.zoom_range(component_id, 2.0f);</span></span></code></pre></div><h3 id="rtk-and-logstreaming-plugins-base64-for-binary-data" tabindex="-1">Rtk and LogStreaming plugins: base64 for binary data <a class="header-anchor" href="#rtk-and-logstreaming-plugins-base64-for-binary-data" aria-label="Permalink to &quot;Rtk and LogStreaming plugins: base64 for binary data&quot;">​</a></h3><p>With v2 it was hard or impossible to use APIs involving binary data in certain language wrappers, specifically Python. This meant that the RTK corrections and log streaming data were exposed as Python strings which didn&#39;t match the binary nature of the data.</p><p>Therefore, we are now using base64 for the data.</p><p>The assumption is that the performance hit of having to encode to and decode from base64 is negligible on platforms where MAVSDK is usually run.</p><p>Mavsdk provides helper functions to help with encoding and decoding base64:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>#include &lt;mavsdk/base64.h&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>std::string encoded = ...;</span></span>
<span class="line"><span>std::vector&lt;uint8_t&gt; binary_data = base64_decode(encoded);</span></span></code></pre></div><h2 id="v2" tabindex="-1">v2 <a class="header-anchor" href="#v2" aria-label="Permalink to &quot;v2&quot;">​</a></h2><h3 id="mavsdk-configuration-1" tabindex="-1">Mavsdk configuration <a class="header-anchor" href="#mavsdk-configuration-1" aria-label="Permalink to &quot;Mavsdk configuration&quot;">​</a></h3><p>The <code>Mavsdk</code> class no longer assumes the configuration of a ground station by default but instead a configuration needs to be passed as a constructor argument.</p><p>The configuration argument sets the identification, so the MAVLink <code>MAV_TYPE</code> and MAVLink component ID (also called compid) of the Mavsdk instance itself, so the source and not the target that you&#39;re connecting to.</p><p>Old instantiation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk;</span></span></code></pre></div><p>New instantiation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk{Mavsdk::Configuration{Mavsdk::ComponentType::GroundStation}};</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>It is still possible to change the configuration later (although not recommended) using <code>Mavsdk::set_configuration(...)</code>.</p></div><p><strong>Rationale:</strong></p><p>The reasons behind this change is to make users aware of this configuration and not assume any default. The problem with a ground station default is that it can be potentially dangerous without the user being aware. We are aware that this makes the API more cumbersome and verbose to use but the goal of Mavsdk is always to erro on the side of safety.</p><p>For instance, in the case where MAVSDK is used on the companion computer, the autopilot would assume that it is connected to a ground station at all time, even if the real ground station was lost.</p><p>Also, having to set the default makes it less likely to misconfigure the overall integration and end up with several components that conflict.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>It is also possible to set the sysid/compid directly, just check out the API of <a href="./cpp/api_reference/classmavsdk_1_1_mavsdk_1_1_configuration.html">Mavsdk::Configuration</a>.</p></div><h3 id="subscription-api" tabindex="-1">Subscription API <a class="header-anchor" href="#subscription-api" aria-label="Permalink to &quot;Subscription API&quot;">​</a></h3><p>The subscription API (also called async functions) has changed:</p><p>Old:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Subscribe</span></span>
<span class="line"><span>telemetry.subscribe_position([](Telemetry::Position position) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;Altitude: &quot; &lt;&lt; position.relative_altitude_m &lt;&lt; &quot; m\\n&quot;;</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Unsubscribe again</span></span>
<span class="line"><span>telemetry.subscribe_position(nullptr);</span></span></code></pre></div><p>New:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Subscribe</span></span>
<span class="line"><span>auto handle = telemetry.subscribe_position([](Telemetry::Position position) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;Altitude: &quot; &lt;&lt; position.relative_altitude_m &lt;&lt; &quot; m\\n&quot;;</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Unsubscribe again</span></span>
<span class="line"><span>telemetry.unsubscribe_position(handle);</span></span></code></pre></div><p><strong>Rationale:</strong> MAVSDK subscriptions had the drawback that there could only be one subscription per API. So subsequent subscribers would overwrite previous subscribers. With the new API there can be more than one subscriber per API, and each can unsubscribe using their own handle.</p><h3 id="server-component-plugins" tabindex="-1">Server component plugins <a class="header-anchor" href="#server-component-plugins" aria-label="Permalink to &quot;Server component plugins&quot;">​</a></h3><p>A lost of work has gone into Mavsdk v2 to support &quot;server&quot; components. These are components that typically run on the drone, e.g. a companion computer or a camera.</p><p>Server component plugins are all plugins that end in <code>_server</code>. They don&#39;t need a <code>System</code> to be instantiated as they are &quot;connected to and don&#39;t care who connects to them&quot;.</p><p>For instance a camera server plugin can be used as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk{Mavsdk::Configuration{Mavsdk::ComponentType::Camera}};</span></span>
<span class="line"><span>auto camera_server = CameraServer{mavsdk.server_component()};</span></span></code></pre></div><p>It&#39;s also possible to add more than one MAVLink component to one MAVSDK instance, e.g. a gimbal could be added like this:</p><h3 id="connecting-to-first-autopilot-system" tabindex="-1">Connecting to first autopilot system <a class="header-anchor" href="#connecting-to-first-autopilot-system" aria-label="Permalink to &quot;Connecting to first autopilot system&quot;">​</a></h3><p>Discovering vehicles/systems required quite a bit of boilerplate code in the past. This has been simplified using a <code>Mavsdk::first_autopilot(double timeout_s)</code> method.</p><p>Old discovering of first autopilot:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>std::cout &lt;&lt; &quot;Waiting to discover system...\\n&quot;;</span></span>
<span class="line"><span>auto prom = std::promise&lt;std::shared_ptr&lt;System&gt;&gt;{};</span></span>
<span class="line"><span>auto fut = prom.get_future();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// We wait for new systems to be discovered, once we find one that has an</span></span>
<span class="line"><span>// autopilot, we decide to use it.</span></span>
<span class="line"><span>mavsdk.subscribe_on_new_system([&amp;mavsdk, &amp;prom]() {</span></span>
<span class="line"><span>    auto system = mavsdk.systems().back();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (system-&gt;has_autopilot()) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;Discovered autopilot\\n&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Unsubscribe again as we only want to find one system.</span></span>
<span class="line"><span>        mavsdk.subscribe_on_new_system(nullptr);</span></span>
<span class="line"><span>        prom.set_value(system);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// We usually receive heartbeats at 1Hz, therefore we should find a</span></span>
<span class="line"><span>// system after around 3 seconds max, surely.</span></span>
<span class="line"><span>if (fut.wait_for(seconds(3)) == std::future_status::timeout) {</span></span>
<span class="line"><span>    std::cerr &lt;&lt; &quot;No autopilot found.\\n&quot;;</span></span>
<span class="line"><span>    return {};</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Get discovered system now.</span></span>
<span class="line"><span>auto system = fut.get();</span></span></code></pre></div><p>New simplified way:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>auto system = mavsdk.first_autopilot(3.0);</span></span></code></pre></div><h2 id="v1" tabindex="-1">v1 <a class="header-anchor" href="#v1" aria-label="Permalink to &quot;v1&quot;">​</a></h2><h3 id="linking" tabindex="-1">Linking <a class="header-anchor" href="#linking" aria-label="Permalink to &quot;Linking&quot;">​</a></h3><p>With version 1, we introduce bigger changes in the way the MAVSDK library is linked to. Essentially, the library is no longer split up in multiple library files, one for the core (e.g. <code>mavsdk.so</code>) and one each for every plugin (e.g. <code>mavsdk_action.so</code>) and instead everything is merged into one library file (usually <code>mavsdk.so</code>).</p><p>This means that linking in cmake gets easier.</p><p>Previously, this was required:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>target_link_libraries(my_executable</span></span>
<span class="line"><span>    MAVSDK::mavsdk_action</span></span>
<span class="line"><span>    MAVSDK::mavsdk_mission</span></span>
<span class="line"><span>    MAVSDK::mavsdk_telemetry</span></span>
<span class="line"><span>    MAVSDK::mavsdk</span></span>
<span class="line"><span>)</span></span></code></pre></div><p>Now, this is all that is needed:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>target_link_libraries(my_executable</span></span>
<span class="line"><span>    MAVSDK::mavsdk</span></span>
<span class="line"><span>)</span></span></code></pre></div><h4 id="rationale" tabindex="-1">Rationale <a class="header-anchor" href="#rationale" aria-label="Permalink to &quot;Rationale&quot;">​</a></h4><p><strong>Why were the &quot;plugins&quot; split up in the first place?</strong></p><ul><li>The plugins were split because they were supposed to be extendable plugins. However, the last few years have shown that this is not really required, as there were no requests or contributions for it.</li><li>Also, having a real plugin architecture is not always easy. For instance, loading plugins at runtime with <code>dlopen</code> <a href="https://github.com/bpowers/musl/blob/master/src/ldso/dlopen.c" target="_blank" rel="noreferrer">is not possible</a> when the library is compiled with <a href="https://www.musl-libc.org/" target="_blank" rel="noreferrer">musl</a>. (We use musl to compile <code>mavsdk_server</code> statically without dependencies, so that it can be shipped with PyPi and runs on any Linux distribution and version as well as cross-compiled on armv6/7/8).</li></ul><p><strong>What are the advantages of the change?</strong></p><ul><li>Having one library to link to is easier and more inline with other libraries. When more functionality is needed, CMakeLists.txt doesn&#39;t need to be changed every time.</li><li>Having only one library makes it easier to check for ABI breaks.</li><li>The file overhead for every plugin is actually very small, so the overhead should be negligible.</li></ul>`,91)]))}const g=s(i,[["render",o]]);export{u as __pageData,g as default};
