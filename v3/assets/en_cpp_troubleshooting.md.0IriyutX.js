import{_ as a,c as s,al as t,o}from"./chunks/framework.JotrKMnz.js";const u=JSON.parse('{"title":"Troubleshooting","description":"","frontmatter":{"github_branch":"v3"},"headers":[],"relativePath":"en/cpp/troubleshooting.md","filePath":"en/cpp/troubleshooting.md"}'),n={name:"en/cpp/troubleshooting.md"};function i(l,e,c,p,r,h){return o(),s("div",null,e[0]||(e[0]=[t(`<h1 id="troubleshooting" tabindex="-1">Troubleshooting <a class="header-anchor" href="#troubleshooting" aria-label="Permalink to &quot;Troubleshooting&quot;">​</a></h1><h2 id="user_callbacks" tabindex="-1">User callbacks <a class="header-anchor" href="#user_callbacks" aria-label="Permalink to &quot;User callbacks {#user_callbacks}&quot;">​</a></h2><p>All callbacks back to the user of the library are called from one thread. The callbacks are stored in a queue. If the user does not return quickly enough from the callback, it can happen that the user callback queue fills up.</p><p>If a callback takes more than one second, the user sees the warning:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[02:56:26|Warn ] Callback took more than 1 second to run.</span></span>
<span class="line"><span>See: https://mavsdk.mavlink.io/main/en/cpp/troubleshooting.html#user_callbacks (system_impl.cpp:327)</span></span></code></pre></div><p>At 10 queued callbacks, the user sees the warning:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[02:56:26|Warn ] User callback queue too slow.</span></span>
<span class="line"><span>See: https://mavsdk.mavlink.io/main/en/cpp/troubleshooting.html#user_callbacks (system_impl.cpp:1213)</span></span></code></pre></div><p>At 100 queued callbacks, the user sees the error message:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[02:56:35|Error] User callback queue overflown</span></span>
<span class="line"><span>See: https://mavsdk.mavlink.io/main/en/cpp/troubleshooting.html#user_callbacks (system_impl.cpp:1218)</span></span></code></pre></div><h3 id="how-to-debug-this" tabindex="-1">How to debug this? <a class="header-anchor" href="#how-to-debug-this" aria-label="Permalink to &quot;How to debug this?&quot;">​</a></h3><p>To determine which callback is blocking the queue, you can set the environment variable <code>MAVSDK_CALLBACK_DEBUGGING</code> to <code>1</code>, which will print more debug information and abort the program as soon as the problem occurs.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>MAVSDK_CALLBACK_DEBUGGING=1 ./my_executable_using_mavsdk</span></span></code></pre></div><p>or:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>export MAVSDK_CALLBACK_DEBUGGING=1</span></span>
<span class="line"><span>./my_executable_using_mavsdk</span></span></code></pre></div><p>You should then see something like this hinting at which callback might be responsible:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>[03:00:02|Warn ] Callback called from telemetry_impl.cpp:533 took more than 1 second to run. (system_impl.cpp:320)</span></span>
<span class="line"><span>[2]    1261673 abort (core dumped)  MAVSDK_CALLBACK_DEBUGGING=1  ...&quot;</span></span></code></pre></div><p>Note that this does not point to the blocking code, but only to the place where your blocking callback was called.</p><h3 id="how-to-avoid-this" tabindex="-1">How to avoid this? <a class="header-anchor" href="#how-to-avoid-this" aria-label="Permalink to &quot;How to avoid this?&quot;">​</a></h3><p>The rule is to spend as little time and CPU in the callbacks as possible. For instance, inside the callbacks you should not wait on other events or sleep.</p><p>If you really want to do something that takes longer inside a callback, the workaround is to just spawn that activity on another thread, e.g. using <code>std::thread</code>:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>void my_callback(Telemetry::Position position)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    std::thread([position]() {</span></span>
<span class="line"><span>        std::this_thread_sleep_for(std::chrono::seconds(3));</span></span>
<span class="line"><span>        my_delayed_action(position);</span></span>
<span class="line"><span>    }).detach();</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="why-did-this-use-to-work" tabindex="-1">Why did this use to work? <a class="header-anchor" href="#why-did-this-use-to-work" aria-label="Permalink to &quot;Why did this use to work?&quot;">​</a></h3><p>Before introducing the callback queue, we used a thread pool of 3 threads to call user callbacks. The thread pool was written to avoid everything from stalling if a user blocked in one of the callbacks. It generally worked provided the user did not block in more than 3 callbacks at any given time.</p><p>However, it had also some disadvantages:</p><ul><li>Due to the thread pool multiple threads could call a function at any given time. This means that one callback can be called from at least two threads at the same time which is quite likely if the callback is called at a high rate. This can create race conditions on the user side unless a mutex is used to prevent this. However, it&#39;s not very intuitive that a mutex is needed for that, and mutexes in general should be avoided, if possible, for performance reasons. Such race conditions also showed up as CI test failures, see: <a href="https://github.com/mavlink/MAVSDK/issues/1010" target="_blank" rel="noreferrer">MAVSDK#1010</a>, <a href="https://github.com/mavlink/MAVSDK/issues/1045" target="_blank" rel="noreferrer">MAVSDK#1045</a>.</li><li>For developers the old thread pool behaviour was unclear and unpredictable. Basically, without code inspection, it was difficult to know if blocking in a callback is safe or not. When trying with one blocking callback, it would work, however, this can create a false sense of security as with 3 blocking callbacks it would suddenly lock up.</li><li>Previously, when this happened, it was difficult to debug because it would either lead to a crash on destruction, or lock up at which point the backtrace of all threads need to be looked at using gdb.</li></ul>`,25)]))}const b=a(n,[["render",i]]);export{u as __pageData,b as default};
