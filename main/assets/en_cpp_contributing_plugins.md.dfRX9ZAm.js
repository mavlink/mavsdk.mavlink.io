import{_ as a,c as s,al as t,o as n}from"./chunks/framework.BVh3rIuO.js";const u=JSON.parse('{"title":"Writing Plugins","description":"","frontmatter":{"github_branch":"main"},"headers":[],"relativePath":"en/cpp/contributing/plugins.md","filePath":"en/cpp/contributing/plugins.md"}'),i={name:"en/cpp/contributing/plugins.md"};function o(l,e,p,r,d,c){return n(),s("div",null,e[0]||(e[0]=[t(`<h1 id="writing-plugins" tabindex="-1">Writing Plugins <a class="header-anchor" href="#writing-plugins" aria-label="Permalink to &quot;Writing Plugins&quot;">​</a></h1><p>MAVSDK-C++ is split into a <a href="https://github.com/mavlink/MAVSDK/tree/main/src/core" target="_blank" rel="noreferrer">core</a> and multiple independent <a href="https://github.com/mavlink/MAVSDK/tree/main/src/mavsdk/plugins" target="_blank" rel="noreferrer">plugins</a>.</p><p>Plugins that are located in the <em>correct location</em> (a subfolder of <strong>/plugins</strong>) and have the <em>correct structure</em> are built at compile time. The <a href="https://github.com/mavlink/MAVSDK/blob/main/CMakeLists.txt" target="_blank" rel="noreferrer">CMakeLists.txt</a> takes care of including the plugin folders and integration tests.</p><h2 id="plugin-architecture" tabindex="-1">Plugin Architecture <a class="header-anchor" href="#plugin-architecture" aria-label="Permalink to &quot;Plugin Architecture&quot;">​</a></h2><p>Plugins should be written so that they are independent of each other (they will still need to be dependent on the core source). This allows plugins to be removed/replaced as needed at the cost of some duplicated functionality across the plugin modules.</p><p>The code for each plugin (and its unit test if one has been defined) is stored in a sub-folder of the <strong>plugins</strong> directory. Integration tests for all plugins in the library are stored in <strong>integration_tests</strong>.</p><p>A simplified view of the folder structure is shown below:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>├── MAVSDK</span></span>
<span class="line"><span>│   └── src</span></span>
<span class="line"><span>│       ├── integration_tests</span></span>
<span class="line"><span>│       ├── mavsdk_server</span></span>
<span class="line"><span>│       └── mavsdk</span></span>
<span class="line"><span>│           ├── core</span></span>
<span class="line"><span>│           └── plugins</span></span>
<span class="line"><span>│               ├── action</span></span>
<span class="line"><span>│               ├── ...</span></span>
<span class="line"><span>│               └── tune</span></span></code></pre></div><p>Each plugin must have the same files/structure, as shown for the &quot;example&quot; plugin below.</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>└── plugins</span></span>
<span class="line"><span>    └── example</span></span>
<span class="line"><span>        ├── CMakeLists.txt</span></span>
<span class="line"><span>        ├── example.cpp</span></span>
<span class="line"><span>        ├── example.h</span></span>
<span class="line"><span>        ├── example_impl.cpp</span></span>
<span class="line"><span>        ├── example_impl.h</span></span>
<span class="line"><span>        └── example_foo_test.cpp  ##optional</span></span></code></pre></div><h2 id="auto-generation" tabindex="-1">Auto-generation <a class="header-anchor" href="#auto-generation" aria-label="Permalink to &quot;Auto-generation&quot;">​</a></h2><p>In order to support various language wrappers around MAVSDK without having to write the same things multiple times, once for every language, we opted to use auto-generation as much as possible. The APIs are defined as <a href="https://github.com/mavlink/MAVSDK-Proto" target="_blank" rel="noreferrer">proto definitions</a>.</p><p>From that, several parts are auto-generated, such as:</p><ul><li>Language wrappers based on gRPC client (formerly called frontend)</li><li>gRPC mavsdk_server in C++ (formerly called backend)</li><li>Plugin C++ headers defining the API.</li></ul><p>Looking at the plugin structure again, this means that some of the files are auto-generated:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>└── plugins</span></span>
<span class="line"><span>    └── example</span></span>
<span class="line"><span>        ├── CMakeLists.txt       # auto-generated</span></span>
<span class="line"><span>        ├── example.cpp          # auto-generated</span></span>
<span class="line"><span>        ├── example.h            # auto-generated</span></span>
<span class="line"><span>        ├── example_impl.cpp     # hand-written (can initially be generated)</span></span>
<span class="line"><span>        ├── example_impl.h       # hand-written (can initially be generated)</span></span>
<span class="line"><span>        └── example_foo_test.cpp  # optional</span></span></code></pre></div><h2 id="create-a-plugin" tabindex="-1">Create a Plugin <a class="header-anchor" href="#create-a-plugin" aria-label="Permalink to &quot;Create a Plugin&quot;">​</a></h2><p>To create a new plugin <strong>do not copy an existing one</strong>, instead follow the steps below:</p><h3 id="think-about-public-api" tabindex="-1">Think about public API <a class="header-anchor" href="#think-about-public-api" aria-label="Permalink to &quot;Think about public API&quot;">​</a></h3><p>Before writing the API, take a step back and think what a user of it needs and expect, rather than what MAVLink already provides.</p><p>Generally, MAVSDK APIs ought to be:</p><ul><li>Simple and easy to use.</li><li>Reduced to the essentials; no functionality that is not actually implemented/supported should be exposed.</li><li>Clearly named and if possible without too much drone jargon and acronyms.</li><li>Abstracted from the MAVLink implementation and therefore to provide specific functionality instead of just forwarding direct MAVLink.</li></ul><p>This advice is important if you are planning to contribute the new plugin back and would like it to get accepted and merged. We are convinced it is also applicable for internal development but - of course - that&#39;s up to you.</p><h3 id="about-proto-structure" tabindex="-1">About proto structure <a class="header-anchor" href="#about-proto-structure" aria-label="Permalink to &quot;About proto structure&quot;">​</a></h3><p>There are a couple of different API types supported for MAVSDK plugins.</p><h4 id="requests" tabindex="-1">Requests: <a class="header-anchor" href="#requests" aria-label="Permalink to &quot;Requests:&quot;">​</a></h4><p>A request is a simple one time call with a response. An example would be the takeoff command of the action plugin:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>service ActionService {</span></span>
<span class="line"><span>    rpc Takeoff(TakeoffRequest) returns(TakeoffResponse) {}</span></span>
<span class="line"><span>    // all other services</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message TakeoffRequest {}</span></span>
<span class="line"><span>message TakeoffResponse {</span></span>
<span class="line"><span>    ActionResult action_result = 1;</span></span>
<span class="line"><span>}</span></span></code></pre></div><p>In this case the request has no argument and no return value except the result but this can vary, e.g. for getters and setters:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>service ActionService {</span></span>
<span class="line"><span>    rpc GetReturnToLaunchAltitude(GetReturnToLaunchAltitudeRequest) returns(GetReturnToLaunchAltitudeResponse) {}</span></span>
<span class="line"><span>    rpc SetReturnToLaunchAltitude(SetReturnToLaunchAltitudeRequest) returns(SetReturnToLaunchAltitudeResponse) {}</span></span>
<span class="line"><span>    // all other services</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message GetReturnToLaunchAltitudeRequest {}</span></span>
<span class="line"><span>message GetReturnToLaunchAltitudeResponse {</span></span>
<span class="line"><span>    ActionResult action_result = 1;</span></span>
<span class="line"><span>    float relative_altitude_m = 2;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>message SetReturnToLaunchAltitudeRequest {</span></span>
<span class="line"><span>    float relative_altitude_m = 1;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>message SetReturnToLaunchAltitudeResponse {</span></span>
<span class="line"><span>    ActionResult action_result = 1;</span></span>
<span class="line"><span>}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Requests can defined SYNC, ASYNC, or BOTH using <code>option (mavsdk.options.async_type) = ...;</code>. The choice depends on the functionality that is being implemented and how it would generally be used. There are no hard rules, it&#39;s something that makes sense to be discussed one by one in a pull request. The default implementation is <code>BOTH</code>.</p></div><h4 id="subscriptions" tabindex="-1">Subscriptions: <a class="header-anchor" href="#subscriptions" aria-label="Permalink to &quot;Subscriptions:&quot;">​</a></h4><p>A subscription is triggered once and will then continuously send responses as a stream. An example would be a the position information of the telemetry plugin:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>service TelemetryService {</span></span>
<span class="line"><span>    rpc SubscribePosition(SubscribePositionRequest) returns(stream PositionResponse) {}</span></span>
<span class="line"><span>    // all other services</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>message SubscribePositionRequest {}</span></span>
<span class="line"><span>message PositionResponse {</span></span>
<span class="line"><span>    Position position = 1;</span></span>
<span class="line"><span>}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Subscriptions also can defined SYNC, ASYNC, or BOTH using <code>option (mavsdk.options.async_type) = ...;</code>. The sync implementation of a subscription is just a getter for the last received value.</p></div><div class="info custom-block"><p class="custom-block-title">INFO</p><p>Subscriptions can be defined finite using <code>option (mavsdk.options.is_finite) = true;</code>. This means that the stream of messages will end at some point instead of continuing indefinitely. An example would be progress updates about a calibration which eventually finishes.</p></div><h3 id="add-api-to-proto" tabindex="-1">Add API to proto <a class="header-anchor" href="#add-api-to-proto" aria-label="Permalink to &quot;Add API to proto&quot;">​</a></h3><p>The first step should be to define the user API in the <a href="https://github.com/mavlink/MAVSDK-Proto" target="_blank" rel="noreferrer">proto repository</a>. This repository is part of the MAVSDK as a submodule in the <code>proto/</code> directory.</p><p>You usually want to work from master in the <code>proto/</code> directory, and then create a feature branch with your additions:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cd proto</span></span>
<span class="line"><span>git switch main</span></span>
<span class="line"><span>git pull</span></span>
<span class="line"><span>git switch -c my-new-plugin</span></span>
<span class="line"><span>cd ../</span></span></code></pre></div><p>Now you can add a folder with your proto file (or copy an existing one and rename it) and draft the API.</p><p>Once the API is defined, it makes sense to commit the changes, push them and make a pull request to <a href="https://github.com/mavlink/MAVSDK-Proto" target="_blank" rel="noreferrer">MAVSDK-Proto</a> to get feedback from the MAVSDK maintainers.</p><h3 id="generate-h-and-cpp-files" tabindex="-1">Generate .h and .cpp files <a class="header-anchor" href="#generate-h-and-cpp-files" aria-label="Permalink to &quot;Generate .h and .cpp files&quot;">​</a></h3><p>Once the proto file has been created, you can generate all files required for the new plugin.</p><ol><li>Run the configure step to prepare the tools required:<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>cmake -DBUILD_MAVSDK_SERVER=ON -Bbuild/default -H.</span></span></code></pre></div></li><li>Install <code>protoc_gen_mavsdk</code> which is required for the auto-generation:<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>pip3 install --user protoc_gen_mavsdk  # Or however you install pip packages</span></span></code></pre></div></li><li>Run the auto-generation:<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>tools/generate_from_protos.sh</span></span></code></pre></div></li><li>Fix style after auto-generation:<div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>tools/fix_style.sh .</span></span></code></pre></div></li></ol><div class="info custom-block"><p class="custom-block-title">INFO</p><p>The files <code>my_new_plugin.h</code> and <code>my_new_plugin.cpp</code> are generated and overwritten every time the script is run. However, the files <code>my_new_plugin_impl.h</code> and <code>my_new_plugin_impl.cpp</code> are only generated once. To re-generate them, delete them and run the script again. This approach is used to prevent the script from overwriting your local changes.</p></div><h3 id="actually-implement-mavlink-messages" tabindex="-1">Actually implement MAVLink messages <a class="header-anchor" href="#actually-implement-mavlink-messages" aria-label="Permalink to &quot;Actually implement MAVLink messages&quot;">​</a></h3><p>You can now add the actual &quot;business logic&quot; which is usually sending and receiving MAVLink messages, waiting for timeouts, etc. All implementation goes into the files <code>my_new_plugin_impl.h</code> and <code>my_new_plugin_impl.cpp</code> or additional files for separate classes required.</p><p>You can also add unit tests with <code>unittest_source_files</code>, as <a href="#adding_unit_tests">discussed below</a>.</p><p>The <a href="https://github.com/mavlink/MAVSDK/tree/main/src/plugins" target="_blank" rel="noreferrer">standard plugins</a> can be reviewed for guidance on how to write plugin code, including how to send and process MAVLink messages.</p><h2 id="plugin-code" tabindex="-1">Plugin Code <a class="header-anchor" href="#plugin-code" aria-label="Permalink to &quot;Plugin Code&quot;">​</a></h2><h3 id="plugin-base-class" tabindex="-1">Plugin Base Class <a class="header-anchor" href="#plugin-base-class" aria-label="Permalink to &quot;Plugin Base Class&quot;">​</a></h3><p>All plugins should derive their implementation from <code>PluginImplBase</code> (<strong>core/plugin_impl_base.h</strong>) and override virtual methods as needed.</p><h3 id="plugin-enable-disable" tabindex="-1">Plugin Enable/Disable <a class="header-anchor" href="#plugin-enable-disable" aria-label="Permalink to &quot;Plugin Enable/Disable&quot;">​</a></h3><p>The SDK provides virtual methods that a plugin should implement to allow the core to better manage resources. For example, to prevent callback being created before the <code>System</code> is instantiated, or messages being sent when a vehicle is not connected.</p><p>Plugin authors should provide an implementation of the following <code>PluginImplBase</code> pure virtual methods:</p><ul><li><a href="#init">init()</a>/<a href="#deinit">deinit()</a>: These are called when a system is created and just before it is destroyed. These should be used for setting up and cleaning everything that depends on having the <code>System</code> instantiated. This includes calls that set up callbacks.</li><li><a href="#enable">enable()</a>/<a href="#disable">disable()</a>: These are called when a vehicle is discovered or has timed out. They should be used for managing resources needed to access a connected system/vehicle (e.g. getting a parameter or changing a setting).</li></ul><p>Additional detail is provided for methods below.</p><h5 id="init" tabindex="-1">init() <a class="header-anchor" href="#init" aria-label="Permalink to &quot;init() {#init}&quot;">​</a></h5><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>The <code>init()</code> method is called when a plugin is instantiated. This happens when a <code>System</code> is constructed (this does not mean that the system actually exists and is connected - it might just be an empty dummy system).</p><p>Plugins should do initialization steps with other parts of the SDK at this state, e.g. set up callbacks with <code>_parent</code> (<code>DeviceImpl</code>).</p><h5 id="deinit" tabindex="-1">deinit() <a class="header-anchor" href="#deinit" aria-label="Permalink to &quot;deinit() {#deinit}&quot;">​</a></h5><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> deinit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>The <code>deinit()</code> method is called before a plugin is destroyed. This usually happens only at the very end, when a <code>MAVSDK</code> instance is destroyed.</p><p>Plugins should cleanup anything that was set up during <code>init()</code>.</p><h5 id="enable" tabindex="-1">enable() <a class="header-anchor" href="#enable" aria-label="Permalink to &quot;enable() {#enable}&quot;">​</a></h5><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> enable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>The <code>enable()</code> method is called when a system is discovered (connected). Plugins should do all initialization/configuration steps that require a system to be connected. For example, setting/getting parameters.</p><p>If any threads, call_every or timeouts are needed, they can be started in this method.</p><h5 id="disable" tabindex="-1">disable() <a class="header-anchor" href="#disable" aria-label="Permalink to &quot;disable() {#disable}&quot;">​</a></h5><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">virtual</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> disable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></div><p>The <code>disable()</code> method is called when a system has timed out. The method is also called before <code>deinit()</code> is called to stop any systems with active plugins from communicating (in order to prevent warnings and errors because communication to the system no longer works).</p><p>If any threads, call_every, or timeouts are running, they should be stopped in this method.</p><h2 id="testing" tabindex="-1">Test Code <a class="header-anchor" href="#testing" aria-label="Permalink to &quot;Test Code {#testing}&quot;">​</a></h2><p>Tests must be created for all new and updated plugin code. The tests should be exhaustive, and cover all aspects of using the plugin API.</p><p>The <a href="https://google.github.io/googletest/primer.html" target="_blank" rel="noreferrer">Google Test Primer</a> provides an excellent overview of how tests are written and used.</p><h3 id="writing-unit-tests" tabindex="-1">Writing Unit Tests <a class="header-anchor" href="#writing-unit-tests" aria-label="Permalink to &quot;Writing Unit Tests&quot;">​</a></h3><p>Most of the existing plugins do not have unit tests, because we do not yet have the ability to <a href="https://github.com/mavlink/MAVSDK/issues/148" target="_blank" rel="noreferrer">mock MAVLink communications</a> (needed to test most plugins). Unit tests are therefore considered optional!</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Comprehensive integration tests should be written instead, with the simulator providing appropriate MAVLink messages.</p></div><h4 id="adding_unit_tests" tabindex="-1">Adding Unit Tests <a class="header-anchor" href="#adding_unit_tests" aria-label="Permalink to &quot;Adding Unit Tests {#adding_unit_tests}&quot;">​</a></h4><p>Unit test files are stored in the same directory as their associated source code.</p><p>In order to include a test in the SDK unit test program (<code>unit_tests_runner</code>), it must be added to the <code>UNIT_TEST_SOURCES</code> variable in the plugin <strong>CMakeLists.txt</strong> file.</p><p>For example, to add the <strong>example_foo_test.cpp</strong> unit test you would append the following lines to its <strong>CMakeLists.txt</strong>:</p><div class="language-cmake vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmake</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">list</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(APPEND UNIT_TEST_SOURCES</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    \${CMAKE_SOURCE_DIR}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/src/plugins/mission/example_foo_test.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(UNIT_TEST_SOURCES </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">\${UNIT_TEST_SOURCES}</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> PARENT_SCOPE)</span></span></code></pre></div><h4 id="unit-test-code" tabindex="-1">Unit Test Code <a class="header-anchor" href="#unit-test-code" aria-label="Permalink to &quot;Unit Test Code&quot;">​</a></h4><p>Unit tests typically include the file to be tested, <strong>mavsdk.h</strong>, and <strong>gtest.h</strong>. There are no standard shared test unit resources so test functions are declared using <code>TEST</code>. All tests in a file should share the same test-case name (the first argument to <code>TEST</code>).</p><h3 id="integration_tests" tabindex="-1">Writing Integration Tests <a class="header-anchor" href="#integration_tests" aria-label="Permalink to &quot;Writing Integration Tests {#integration_tests}&quot;">​</a></h3><p>MAVSDK provides the <code>integration_tests_runner</code> application for running the integration tests and some helper code to make it easier to log tests and run them against the simulator.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Check out the <a href="https://google.github.io/googletest/primer.html" target="_blank" rel="noreferrer">Google Test Primer</a> and the <a href="https://github.com/mavlink/MAVSDK/tree/main/src/integration_tests" target="_blank" rel="noreferrer">integration_tests</a> for our existing plugins to better understand how to write your own!</p></div><h4 id="adding-integration-tests" tabindex="-1">Adding Integration Tests <a class="header-anchor" href="#adding-integration-tests" aria-label="Permalink to &quot;Adding Integration Tests&quot;">​</a></h4><p>In order to run an integration test it needs to be added to the <code>integration_tests_runner</code> program.</p><p>Integration tests for core functionality and plugins delivered by the project are stored in <a href="https://github.com/mavlink/MAVSDK/tree/main/src/integration_tests" target="_blank" rel="noreferrer">MAVSDK/src/integration_tests</a>. The files are added to the test program in that folder&#39;s <a href="https://github.com/mavlink/MAVSDK/blob/main/src/integration_tests/CMakeLists.txt" target="_blank" rel="noreferrer">CMakeLists.txt</a> file:</p><div class="language-cmake vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cmake</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># This includes all GTests that run integration tests</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">add_executable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(integration_tests_runner</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ../core/unittests_main.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    simple_connect.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    async_connect.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    telemetry_simple.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    gimbal.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    transition_multicopter_fixedwing.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    follow_me.cpp</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h4 id="integration-test-files-code" tabindex="-1">Integration Test Files/Code <a class="header-anchor" href="#integration-test-files-code" aria-label="Permalink to &quot;Integration Test Files/Code&quot;">​</a></h4><p>The main MAVSDK-specific functionality is provided by <a href="https://github.com/mavlink/MAVSDK/blob/main/src/integration_tests/integration_test_helper.h" target="_blank" rel="noreferrer">integration_test_helper.h</a>. This provides access to the <a href="./../guide/dev_logging.html">Plugin/Test Logger</a> and a shared test class <code>SitlTest</code> for setting up and tearing down the PX4 simulator.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>All tests running against SITL can be declared using <code>TEST_F</code> and have a first argument <code>SitlTest</code> as shown. This is required in order to use the shared class to set up and tear down the simulator between tests.</p></div><p>For reference inspect the <a href="https://github.com/mavlink/MAVSDK/blob/main/src/integration_tests" target="_blank" rel="noreferrer">existing integration tests</a>.</p><h2 id="example-code" tabindex="-1">Example Code <a class="header-anchor" href="#example-code" aria-label="Permalink to &quot;Example Code&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>It is quicker and easier to write and modify <a href="#integration_tests">integration tests</a> than examples. Do not write example code until the plugin has been accepted!</p></div><p>A simple example should be written that demonstrates basic usage of its API by 3rd parties. The example need not cover all functionality, but should demonstrate enough that developers can see how it is used and how the example might be extended.</p><p>Where possible examples should demonstrate realistic use cases such that the code can usefully be copied and reused by external developers.</p><h2 id="documentation" tabindex="-1">Documentation <a class="header-anchor" href="#documentation" aria-label="Permalink to &quot;Documentation&quot;">​</a></h2><h3 id="in-source-comments" tabindex="-1">In-Source Comments <a class="header-anchor" href="#in-source-comments" aria-label="Permalink to &quot;In-Source Comments&quot;">​</a></h3><p>The public API must be fully documented using the proto files.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>The in-source comments will be compiled to markdown and included in the <a href="./../api_reference/">API Reference</a>. The process is outlined in <a href="./documentation.html#api-reference">Documentation &gt; API Reference</a>.</p></div><p>Internal/implementation classes need not be documented, but should be written using expressive naming of variables and functions to help the reader. Anything unexpected or special however warrants an explanation as a comment.</p><h3 id="example-code-documentation" tabindex="-1">Example Code Documentation <a class="header-anchor" href="#example-code-documentation" aria-label="Permalink to &quot;Example Code Documentation&quot;">​</a></h3><p>The plugin example should be documented in markdown following the same pattern as the existing <a href="./../examples/">examples</a>.</p><p>Generally this involves explaining what the example does and displaying the source. The explanation of how the code works is usually deferred to <a href="#guide">guide documentation</a>.</p><h3 id="guide" tabindex="-1">Guide Documentation <a class="header-anchor" href="#guide" aria-label="Permalink to &quot;Guide Documentation {#guide}&quot;">​</a></h3><p>Ideally, <a href="./../guide/">guide</a> documentation should be created. This should be based on example code.</p><p>The purpose of the guide is to:</p><ul><li>Show how different parts of the API can be used together</li><li>Highlight usage patterns and limitations that may not be obvious from API reference</li><li>Provide code fragments that can easily be reused</li></ul>`,114)]))}const g=a(i,[["render",o]]);export{u as __pageData,g as default};
