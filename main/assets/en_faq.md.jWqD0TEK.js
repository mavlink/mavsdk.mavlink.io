import{_ as a,c as o,al as t,o as n}from"./chunks/framework.BVh3rIuO.js";const u=JSON.parse('{"title":"FAQ","description":"","frontmatter":{"github_branch":"main"},"headers":[],"relativePath":"en/faq.md","filePath":"en/faq.md"}'),i={name:"en/faq.md"};function r(s,e,l,d,h,p){return n(),o("div",null,e[0]||(e[0]=[t(`<h1 id="faq" tabindex="-1">FAQ <a class="header-anchor" href="#faq" aria-label="Permalink to &quot;FAQ&quot;">​</a></h1><h3 id="why-was-the-core-of-mavsdk-written-in-c" tabindex="-1">Why was the core of MAVSDK written in C++? <a class="header-anchor" href="#why-was-the-core-of-mavsdk-written-in-c" aria-label="Permalink to &quot;Why was the core of MAVSDK written in C++?&quot;">​</a></h3><p>The aim was to have an API in a language which is cross-platform and has many language bindings. The library also needs to be lightweight and fast, so it does not slow down for onboard usage at higher rate messaging. Additionally, MAVSDK should be able to run efficiently in embedded setups, e.g. as part of an app or onboard a drone on a companion computer, as well as provide a simple and safe API. This favoured C++ over C as it allows for more expressive but type-safe APIs using standard library containers (e.g. <code>std::vector&lt;MissionItem&gt;</code>) for usage in embedded setups.</p><h3 id="are-multiple-vehicles-supported" tabindex="-1">Are multiple vehicles supported? <a class="header-anchor" href="#are-multiple-vehicles-supported" aria-label="Permalink to &quot;Are multiple vehicles supported?&quot;">​</a></h3><p>Yes.</p><ul><li>The MAVSDK C++ library allows C++ applications to connect to multiple vehicles at a time.</li><li>Python, Swift, and other language wrappers can only connect to a <em>single vehicle at a time</em>. However you can instantiate multiple copies of wrappers in order to connect to multiple systems.</li></ul><p>A maximum of 255 vehicles can be connected.</p><blockquote><p><strong>Note</strong> The maximum number of vehicles is defined by the MAVLink protocol. MAVLink refers to vehicles as &quot;systems&quot;, which are comprised of components (for example, a drone with a gimbal and a camera). Each system has a network-unique MAVLink system ID, with a value between 1 and 255 (0 is a &quot;broadcast address&quot;). Each component in a system shares its system id, and has a system-unique component ID, again with a value 1 and 255.</p></blockquote><h3 id="is-mavlink-1-supported" tabindex="-1">Is MAVLink 1 supported? <a class="header-anchor" href="#is-mavlink-1-supported" aria-label="Permalink to &quot;Is MAVLink 1 supported?&quot;">​</a></h3><p>No. MAVSDK only supports <a href="https://mavlink.io/en/guide/mavlink_2.html" target="_blank" rel="noreferrer">MAVLink 2.0</a>.</p><h3 id="what-sorts-of-vehicles-are-supported" tabindex="-1">What sorts of vehicles are supported? <a class="header-anchor" href="#what-sorts-of-vehicles-are-supported" aria-label="Permalink to &quot;What sorts of vehicles are supported?&quot;">​</a></h3><p>The MAVSDK API is designed for interacting with <em>aircraft</em>. It has primarily been tested for use with multicopters, but also has basic support for fixed wing and <a href="./cpp/guide/vtol.html">VTOL</a>.</p><p>The API <em>may</em> &quot;work&quot; with ground-based or other types of vehicles, but some methods will not make sense. This use-case is mostly unsupported and untested.</p><h3 id="does-mavsdk-support-indoor-use" tabindex="-1">Does MAVSDK support indoor use? <a class="header-anchor" href="#does-mavsdk-support-indoor-use" aria-label="Permalink to &quot;Does MAVSDK support indoor use?&quot;">​</a></h3><p>Indoor use is supported, however, some modes such as mission or position control are not available indoor, unless some additional positioning method is available (e.g. optical flow, visual-inertial odometry, a motion capture system, etc.).</p><p>Note that PX4 currently does not support missions using &quot;local coordinates&quot; (i.e. meters) but only supports using &quot;global coordinates&quot; (i. e. latitude/longitude).</p><h3 id="what-uav-flight-stacks-are-supported" tabindex="-1">What UAV flight stacks are supported? <a class="header-anchor" href="#what-uav-flight-stacks-are-supported" aria-label="Permalink to &quot;What UAV flight stacks are supported?&quot;">​</a></h3><p>MAVSDK, so far, is optimised for use with the PX4 flight stack and all testing is done against PX4.</p><p>While many features should work on other flight stacks there may be implementation differences at the <a href="https://mavlink.io/en/protocol/overview.html" target="_blank" rel="noreferrer">MAVLink microservices level</a> which means that not every API will work. For example, PX4 and ArduPilot implement the parameter protocol differently, and vary slightly in the mission upload/download protocol (e.g. ArduPilot uses the 0 entry as the home position).</p><blockquote><p><strong>Note</strong> The SDK welcomes contributions to better support flight stacks other than PX4. We do however expect contributors to also help with testing and maintenance support for using the SDK with their autopilot.</p></blockquote><h3 id="are-serial-connections-supported" tabindex="-1">Are serial connections supported? <a class="header-anchor" href="#are-serial-connections-supported" aria-label="Permalink to &quot;Are serial connections supported?&quot;">​</a></h3><p>Yes. Serial, TCP, and UDP connections are supported, see <a href="./cpp/guide/connections.html">notes on connection</a>.</p><h3 id="why-is-libcurl-a-dependency" tabindex="-1">Why is libCURL a dependency? <a class="header-anchor" href="#why-is-libcurl-a-dependency" aria-label="Permalink to &quot;Why is libCURL a dependency?&quot;">​</a></h3><p>libCURL will be required to download the camera definition file which is referenced in <a href="https://mavlink.io/en/messages/common.html#CAMERA_INFORMATION" target="_blank" rel="noreferrer">CAMERA_INFORMATION</a>. It might also come in handy whenever any other REST resources are required.</p><h3 id="how-are-plugins-added" tabindex="-1">How are plugins added? <a class="header-anchor" href="#how-are-plugins-added" aria-label="Permalink to &quot;How are plugins added?&quot;">​</a></h3><p>Check out <a href="./cpp/contributing/plugins.html">C++/Contributing/Plugins</a>.</p><h3 id="can-a-plugin-depend-on-another-one" tabindex="-1">Can a plugin depend on another one? <a class="header-anchor" href="#can-a-plugin-depend-on-another-one" aria-label="Permalink to &quot;Can a plugin depend on another one?&quot;">​</a></h3><p>Yes - but it should not! The idea is that plugins don&#39;t have any coupling between each other which allows for any plugin to be changed or removed without breaking the rest. This will lead to some duplication at places, and that&#39;s an acceptable trade-off. If the same code is used in many places, it can always be moved to core and get re-used from there.</p><p>We have sometimes moved functionality from plugins to the core if it was exposed in multiple plugins. As an example mission upload/download has been moved to the core so it can be used in the Mission plugin as well as the MissionRaw and Geofence plugins.</p><h3 id="can-mavsdk-run-on-an-embedded-platform-microcontroller" tabindex="-1">Can MAVSDK run on an embedded platform / microcontroller? <a class="header-anchor" href="#can-mavsdk-run-on-an-embedded-platform-microcontroller" aria-label="Permalink to &quot;Can MAVSDK run on an embedded platform / microcontroller?&quot;">​</a></h3><p>MAVSDK is generally written at a bit higher level, geared towards ARM devices such as a Raspberry Pi, a smartphone, or a similar device with equal/better performance.</p><p>As MAVSDK does not actually require too much CPU power, it could in theory be run on a microcontroller such as an ARM Cortex M4, however, it would require the POSIX APIs for serial and networking communication, as well as the C++ standard library for classes/functions such as <code>std::thread</code> or <code>std::vector</code>.</p><p>The recommendation for usage with a microcontroller would be to use the pure <a href="https://mavlink.io/en/mavgen_c/" target="_blank" rel="noreferrer">C MAVLink headers</a>.</p><h3 id="why-is-mavlink-passthrough-only-available-in-c" tabindex="-1">Why is MAVLink Passthrough only available in C++? <a class="header-anchor" href="#why-is-mavlink-passthrough-only-available-in-c" aria-label="Permalink to &quot;Why is MAVLink Passthrough only available in C++?&quot;">​</a></h3><p>The C++ MAVLink passthrough plugin basically exposes the direct C MAVLink API. While it would be nice to have access to all MAVLink messages in the language wrappers, there are some technical challenges:</p><ul><li>Essentially, it would mean that all MAVLink APIs would have to be duplicated by the <a href="https://github.com/mavlink/MAVSDK-Proto/tree/main/protos" target="_blank" rel="noreferrer">proto APIs</a>. This would increase the API and code size considerably.</li><li>Alternatively, the API could be exposed without types, using some sort of runtime access like <code>get_message(&quot;ATTITUDE&quot;).get_field(&quot;pitch&quot;).as_float()</code>. This would come with the cost of no type safety and runtime overhead for parsing the strings.</li></ul><p>From a MAVSDK project point of view, there is also an advantage of not having a passthrough available in language wrappers; it encourages that required features are contributed back to the open-source project, rather than implemented in private using passthrough, and thus benefitting everyone.</p><h3 id="why-is-grpc-used-for-the-language-wrappers" tabindex="-1">Why is gRPC used for the language wrappers? <a class="header-anchor" href="#why-is-grpc-used-for-the-language-wrappers" aria-label="Permalink to &quot;Why is gRPC used for the language wrappers?&quot;">​</a></h3><p>There are multiple ways to support multiple programming languages all with their pros and cons:</p><ol><li>Separate implementation per language: <code>+</code> Nice native API. <code>+</code> No non-native dependencies (often) in language wrappers. <code>-</code> Lots of implementation effort required, does not scale well with a small team. <code>-</code> Languages will not have consistency of feature parity.</li><li>Direct language bindings based on <a href="http://www.swig.org/" target="_blank" rel="noreferrer">Swig</a>. <code>+</code> Many languages &quot;almost for free&quot;. <code>-</code> Not always optimal/super clean API, unless another layer is written manually. <code>-</code> Requires linking to non-native dependencies.</li><li>Direct language bindings manually written, or based on various tools like <a href="https://github.com/pybind/pybind11" target="_blank" rel="noreferrer">pybind11</a>. <code>+</code> Some languages &quot;almost for free&quot;. <code>-</code> Varies on the language. If done manually likely to have bugs. <code>-</code> Requires linking to nan-native dependencies.</li><li>Language bindings based on proto definitions (protobuf) and gRPC. <code>+</code> Nice native APIs can be auto-generated from proto files. <code>+</code> No non-native dependencies in language wrappers. <code>+</code> mavsdk_server (gRPC server) can be run on other machine, or over network, in cloud, etc. <code>-</code> gRPC requires quite a few dependencies.</li></ol><p>When writing the language wrappers for MAVSDK we decided to try gRPC, however, we underestimated just how much work was required to write all the auto-generation for the various function signatures (sync, async, result handling, streams, etc.), and also were not aware about the pain that comes with every dependency.</p><p>You can <a href="./cpp/contributing/autogen.html">read more about the auto-generation</a>, and <a href="./cpp/contributing/plugins.html#add-api-to-proto">learn how to add functionality</a>.</p><p>We are not ruling out direct-bindings for the future, there is e.g. a <a href="https://github.com/mavlink/MAVSDK/pull/1283" target="_blank" rel="noreferrer">prototype for Python using pybind11</a>, so this is an ongoing topic.</p><h3 id="use-of-deleted-function-mavsdk" tabindex="-1">Use of deleted function Mavsdk() <a class="header-anchor" href="#use-of-deleted-function-mavsdk" aria-label="Permalink to &quot;Use of deleted function Mavsdk()&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>error: use of deleted function ‘mavsdk::Mavsdk::Mavsdk()’</span></span>
<span class="line"><span></span></span>
<span class="line"><span>mavsdk::Mavsdk mavsdk;</span></span></code></pre></div><p>The API to construct <code>Mavsdk</code> has changed with v2. Check <a href="./cpp/api_changes.html">API changes</a>:</p>`,46)]))}const m=a(i,[["render",r]]);export{u as __pageData,m as default};
