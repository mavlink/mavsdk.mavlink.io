import{_ as a,c as e,al as n,o as t}from"./chunks/framework.BVh3rIuO.js";const u=JSON.parse('{"title":"API Changes","description":"","frontmatter":{"github_branch":"main"},"headers":[],"relativePath":"en/cpp/api_changes.md","filePath":"en/cpp/api_changes.md"}'),i={name:"en/cpp/api_changes.md"};function o(p,s,l,r,c,d){return t(),e("div",null,s[0]||(s[0]=[n(`<h1 id="api-changes" tabindex="-1">API Changes <a class="header-anchor" href="#api-changes" aria-label="Permalink to &quot;API Changes&quot;">​</a></h1><p>This page tracks changes between versions.</p><p>It covers both breaking (incompatible) and non-breaking changes.</p><h2 id="semantic-versioning" tabindex="-1">Semantic Versioning <a class="header-anchor" href="#semantic-versioning" aria-label="Permalink to &quot;Semantic Versioning&quot;">​</a></h2><p>MAVSDK follows <a href="https://semver.org/" target="_blank" rel="noreferrer">semver/Semantic Versioning</a> conventions where as possible.</p><p>The version number has the format: <strong>major.minor.patch</strong>. Individual parts of the number are iterated when the:</p><ul><li><strong>major</strong>: API is changed, or functionality is removed.</li><li><strong>minor</strong>: API is extended, functionality is added.</li><li><strong>patch</strong>: API is not changed, functionality is not changed, but a bug is fixed.</li></ul><p>This means that breaking changes to the API result in a bump of the major version number (e.g. 1.4.3 to 2.0.0).</p><blockquote><p><strong>note</strong>: bumping of the major version is unrelated to the stability of the library. E.g. v2.0.0 is not by definition more stable than v1.4.18. It just means that the API has changed with v2. As development is carried on, stability is likely increasing whenever the minor or patch versions increase as incremental fixes are added.</p></blockquote><h2 id="v2" tabindex="-1">v2 <a class="header-anchor" href="#v2" aria-label="Permalink to &quot;v2&quot;">​</a></h2><h3 id="mavsdk-configuration" tabindex="-1">Mavsdk configuration <a class="header-anchor" href="#mavsdk-configuration" aria-label="Permalink to &quot;Mavsdk configuration&quot;">​</a></h3><p>The <code>Mavsdk</code> class no longer assumes the configuration of a ground station by default but instead a configuration needs to be passed as a constructor argument.</p><p>The configuration argument sets the identification, so the MAVLink <code>MAV_TYPE</code> and MAVLink component ID (also called compid) of the Mavsdk instance itself, so the source and not the target that you&#39;re connecting to.</p><p>Old instantiation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk;</span></span></code></pre></div><p>New instantiation:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk{Mavsdk::Configuration{Mavsdk::ComponentType::GroundStation}};</span></span></code></pre></div><p><strong>Note:</strong> It is still possible to change the configuration later (although not recommended) using <code>Mavsdk::set_configuration(...)</code>.</p><p><strong>Rationale:</strong></p><p>The reasons behind this change is to make users aware of this configuration and not assume any default. The problem with a ground station default is that it can be potentially dangerous without the user being aware. We are aware that this makes the API more cumbersome and verbose to use but the goal of Mavsdk is always to erro on the side of safety.</p><p>For instance, in the case where MAVSDK is used on the companion computer, the autopilot would assume that it is connected to a ground station at all time, even if the real ground station was lost.</p><p>Also, having to set the default makes it less likely to misconfigure the overall integration and end up with several components that conflict.</p><p><strong>Note:</strong> It is also possible to set the sysid/compid directly, just check out the API of <a href="./cpp/api_reference/classmavsdk_1_1_mavsdk_1_1_configuration.html">Mavsdk::Configuration</a>.</p><h3 id="subscription-api" tabindex="-1">Subscription API <a class="header-anchor" href="#subscription-api" aria-label="Permalink to &quot;Subscription API&quot;">​</a></h3><p>The subscription API (also called async functions) has changed:</p><p>Old:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Subscribe</span></span>
<span class="line"><span>telemetry.subscribe_position([](Telemetry::Position position) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;Altitude: &quot; &lt;&lt; position.relative_altitude_m &lt;&lt; &quot; m\\n&quot;;</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Unsubscribe again</span></span>
<span class="line"><span>telemetry.subscribe_position(nullptr);</span></span></code></pre></div><p>New:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// Subscribe</span></span>
<span class="line"><span>auto handle = telemetry.subscribe_position([](Telemetry::Position position) {</span></span>
<span class="line"><span>    std::cout &lt;&lt; &quot;Altitude: &quot; &lt;&lt; position.relative_altitude_m &lt;&lt; &quot; m\\n&quot;;</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Unsubscribe again</span></span>
<span class="line"><span>telemetry.unsubscribe_position(handle);</span></span></code></pre></div><p><strong>Rationale:</strong> MAVSDK subscriptions had the drawback that there could only be one subscription per API. So subsequent subscribers would overwrite previous subscribers. With the new API there can be more than one subscriber per API, and each can unsubscribe using their own handle.</p><h3 id="server-component-plugins" tabindex="-1">Server component plugins <a class="header-anchor" href="#server-component-plugins" aria-label="Permalink to &quot;Server component plugins&quot;">​</a></h3><p>A lost of work has gone into Mavsdk v2 to support &quot;server&quot; components. These are components that typically run on the drone, e.g. a companion computer or a camera.</p><p>Server component plugins are all plugins that end in <code>_server</code>. They don&#39;t need a <code>System</code> to be instantiated as they are &quot;connected to and don&#39;t care who connects to them&quot;.</p><p>For instance a camera server plugin can be used as follows:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>Mavsdk mavsdk{Mavsdk::Configuration{Mavsdk::ComponentType::Camera}};</span></span>
<span class="line"><span>auto camera_server = mavsdk::CameraServer{mavsdk.server_component()};</span></span></code></pre></div><p>It&#39;s also possible to add more than one MAVLink component to one MAVSDK instance, e.g. a gimbal could be added like this:</p><h3 id="connecting-to-first-autopilot-system" tabindex="-1">Connecting to first autopilot system <a class="header-anchor" href="#connecting-to-first-autopilot-system" aria-label="Permalink to &quot;Connecting to first autopilot system&quot;">​</a></h3><p>Discovering vehicles/systems required quite a bit of boilerplate code in the past. This has been simplified using a <code>Mavsdk::first_autopilot(double timeout_s)</code> method.</p><p>Old discovering of first autopilot:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>std::cout &lt;&lt; &quot;Waiting to discover system...\\n&quot;;</span></span>
<span class="line"><span>auto prom = std::promise&lt;std::shared_ptr&lt;System&gt;&gt;{};</span></span>
<span class="line"><span>auto fut = prom.get_future();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// We wait for new systems to be discovered, once we find one that has an</span></span>
<span class="line"><span>// autopilot, we decide to use it.</span></span>
<span class="line"><span>mavsdk.subscribe_on_new_system([&amp;mavsdk, &amp;prom]() {</span></span>
<span class="line"><span>    auto system = mavsdk.systems().back();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    if (system-&gt;has_autopilot()) {</span></span>
<span class="line"><span>        std::cout &lt;&lt; &quot;Discovered autopilot\\n&quot;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Unsubscribe again as we only want to find one system.</span></span>
<span class="line"><span>        mavsdk.subscribe_on_new_system(nullptr);</span></span>
<span class="line"><span>        prom.set_value(system);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// We usually receive heartbeats at 1Hz, therefore we should find a</span></span>
<span class="line"><span>// system after around 3 seconds max, surely.</span></span>
<span class="line"><span>if (fut.wait_for(seconds(3)) == std::future_status::timeout) {</span></span>
<span class="line"><span>    std::cerr &lt;&lt; &quot;No autopilot found.\\n&quot;;</span></span>
<span class="line"><span>    return {};</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Get discovered system now.</span></span>
<span class="line"><span>auto system = fut.get();</span></span></code></pre></div><p>New simplified way:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>auto system = mavsdk.first_autopilot(3.0);</span></span></code></pre></div><h2 id="v1" tabindex="-1">v1 <a class="header-anchor" href="#v1" aria-label="Permalink to &quot;v1&quot;">​</a></h2><h3 id="linking" tabindex="-1">Linking <a class="header-anchor" href="#linking" aria-label="Permalink to &quot;Linking&quot;">​</a></h3><p>With version 1, we introduce bigger changes in the way the MAVSDK library is linked to. Essentially, the library is no longer split up in multiple library files, one for the core (e.g. <code>mavsdk.so</code>) and one each for every plugin (e.g. <code>mavsdk_action.so</code>) and instead everything is merged into one library file (usually <code>mavsdk.so</code>).</p><p>This means that linking in cmake gets easier.</p><p>Previously, this was required:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>target_link_libraries(my_executable</span></span>
<span class="line"><span>    MAVSDK::mavsdk_action</span></span>
<span class="line"><span>    MAVSDK::mavsdk_mission</span></span>
<span class="line"><span>    MAVSDK::mavsdk_telemetry</span></span>
<span class="line"><span>    MAVSDK::mavsdk</span></span>
<span class="line"><span>)</span></span></code></pre></div><p>Now, this is all that is needed:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>target_link_libraries(my_executable</span></span>
<span class="line"><span>    MAVSDK::mavsdk</span></span>
<span class="line"><span>)</span></span></code></pre></div><h4 id="rationale" tabindex="-1">Rationale <a class="header-anchor" href="#rationale" aria-label="Permalink to &quot;Rationale&quot;">​</a></h4><p><strong>Why were the &quot;plugins&quot; split up in the first place?</strong></p><ul><li>The plugins were split because they were supposed to be extendable plugins. However, the last few years have shown that this is not really required, as there were no requests or contributions for it.</li><li>Also, having a real plugin architecture is not always easy. For instance, loading plugins at runtime with <code>dlopen</code> <a href="https://github.com/bpowers/musl/blob/master/src/ldso/dlopen.c" target="_blank" rel="noreferrer">is not possible</a> when the library is compiled with <a href="https://www.musl-libc.org/" target="_blank" rel="noreferrer">musl</a>. (We use musl to compile <code>mavsdk_server</code> statically without dependencies, so that it can be shipped with PyPi and runs on any Linux distribution and version as well as cross-compiled on armv6/7/8).</li></ul><p><strong>What are the advantages of the change?</strong></p><ul><li>Having one library to link to is easier and more inline with other libraries. When more functionality is needed, CMakeLists.txt doesn&#39;t need to be changed every time.</li><li>Having only one library makes it easier to check for ABI breaks.</li><li>The file overhead for every plugin is actually very small, so the overhead should be negligible.</li></ul>`,55)]))}const g=a(i,[["render",o]]);export{u as __pageData,g as default};
